package main

import (
	"os"
	"bufio"
	"fmt"
	"log"
	"strings"
	"strconv"
)

// StanError represents on error instance parsed from phpstan output
type StanError struct {
	// File is the full path of the file
	File string
	// Line is the line in which the error was detected
	Line int
	// Message is the error message generated by phpstan. Fixers can read this to see if they can do something about it
	Message string
}

func main() {
	stanErrors := parseFile()
	fixers := []StanFixer{phpDocParamMissingType}

	for _, stanError := range stanErrors {
		for _, fixer := range fixers {
			fixed, err := fixer(stanError)
			if err != nil {
				fmt.Println(err)
			}
			if fixed {
				fmt.Println("fixed ", stanError.File)
			}
		}
	}
}

// parseFile parses the file phpstan.output
func parseFile() []StanError {
	file, err := os.Open("phpstan.output")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)

	stanErrors := make([]StanError, 0)
	for scanner.Scan() {
		stanError, err := parseLine(scanner.Text())
		if err != nil {
			log.Fatal(err)
		}
		stanErrors = append(stanErrors, stanError)
	}

	if err = scanner.Err(); err != nil {
		log.Fatal(err)
	}

	return stanErrors
}

func parseLine(line string) (StanError, error) {
	parts := strings.Split(line, ":")
	var stanError StanError
	if len(parts) < 3 {
		return stanError, fmt.Errorf("cannot parse error '%s'", line)
	}

	stanError.File = parts[0]
	lineNumber, err := strconv.Atoi(parts[1])
	if err != nil {
		return stanError, fmt.Errorf("cannot parse line number: '%s'", err)
	}
	stanError.Line = lineNumber
	stanError.Message = strings.Join(parts[2:], ":")

	return stanError, nil
}
